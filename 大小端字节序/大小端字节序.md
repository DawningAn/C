# 大小端字节序

# **什么是大端小端**： 

​		大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中

​		小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中

# **为什么有大端和小端**：

​		为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元 都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short 型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32 位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因 此就导致了大端存储模式和小端存储模式。我们常用的 X86 结构是小端模式，而 KEIL C51 则 为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式 还是小端模式。由于各硬件商，按自己的构想设计硬件，导致了硬件设计不同，工作原理也有差异。所以有的硬件采用了大端模式，有的硬件采用了小端模式。

# **程序判断当前机器字节序**

例如（下面程序可以判断当前机器的字节序）：

```c
# define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main() {

	//大小端 字节序
	int a = 1;
	// 0x 00 00 00 01
	char* p = (char*)&a;
	if (*p == 1) {  //或者*(char*)&a == 1
		printf("小端");
	}
	else {
		printf("大端");
	}
	return 0;
}

//也可以将判断过程封装为一个函数实现
int check_sys()
{
 int i = 1;
 return (*(char *)&i);
}
```

简单来说在监视窗口里内存顺序（显示4列）：

​	

![image-20220809113823990](D:\Gitee\c-language\大小端字节序\内存地址中数据存放.png)

例如要存放的数据：0x12345678
低字节为:0x12
高字节为:0x78



**1.大端模式：**

内存低地址 --------------------> 内存高地址
0x12  |  0x34  |  0x56  |  0x78

**即高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。**



**2.小端模式：**

内存低地址 --------------------> 内存高地址
0x78  |  0x56  |  0x34  |  0x12

**即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。**



也可以用下面的实现方式来判断字节序，即check函数实现不同

```c
int check()
{
 union
 {
 int i;
 char c;
 }un;
 un.i = 1;
 return un.c;
}
//主函数仍然不变
int main()
{
 int ret = check_sys();
 if(ret == 1)
 {
 printf("小端\n");
 }
 else
 {
 printf("大端\n");
 }
 return 0;
}
```

